### 1. Introducción a la Búsqueda en IA

Un agente de IA, dado un problema, debe resolverlo o proponer una solución mediante aprendizaje, búsqueda y planificación.

- **Definición:** Un algoritmo de búsqueda es un conjunto de instrucciones diseñadas para localizar un elemento con ciertas propiedades dentro de una estructura de datos.
- **Contexto:** Se parte de un estado inicial sin saber la secuencia exacta de etapas para llegar a la meta.
- **Aplicaciones reales:** Búsqueda de rutas, Problema del viajante (TSP), diseño VLSI, navegación robótica y visión artificial
### 2. Propiedades y Medidas de Evaluación

Para evaluar un solucionador o algoritmo de búsqueda, se consideran cuatro propiedades fundamentales:

1. **Complejidad temporal:** El tiempo requerido para obtener la solución.
2. **Complejidad espacial:** La cantidad de memoria o espacio necesario.
3. **Completitud:** Garantía de que la estrategia encontrará una solución si esta existe.
4. **Calidad (Optimidad):** Si existen varias soluciones, ¿asegura la estrategia el resultado óptimo (menor costo o pasos)?.
    - _Nota:_ Un inconveniente frecuente es la explosión combinatoria.

### 3. Tipologías de Búsqueda

Los solucionadores se clasifican según la información disponible del dominio:
#### A. Búsqueda a Ciegas (Sin información)

El agente no tiene información sobre el dominio para determinar el mejor operador; solo distingue si un nodo es meta o no.

- **Características:** Crece el árbol sistemáticamente y no analiza la distancia a la solución.
- **Algoritmos principales:**
    - **Búsqueda en Amplitud (Anchura).**
    ![[Pasted image 20251203114258.png]]
    - **Búsqueda en Profundidad.**
![[Pasted image 20251203114336.png]]
    - **Costo Uniforme:** es un algoritmo de búsqueda árbol utilizado para el desplazamiento o la búsqueda de un árbol ponderado, estructura de árbol, o un grafo. La búsqueda comienza en el nodo raíz. La búsqueda, continúa visitando el siguiente nodo que tiene el menor costo total de la raíz.
    ![[Pasted image 20251203114848.png]]

- **Comparativa:** Los algoritmos varían en tiempo, espacio y completitud. Por ejemplo, la búsqueda en amplitud es completa y óptima (si los costos son iguales), pero tiene alta complejidad espacial ($O(b^d)$).
![[Pasted image 20251203105812.png]]
#### B. Búsqueda Heurística (Informada)

El agente posee información sobre el problema (heurística) para elegir los operadores más convenientes y estimar la distancia a la solución.
- **Objetivo:** Localizar soluciones aproximadas o exactas de manera más eficaz, sacrificando a veces la perfección por la eficiencia.
- **Algoritmos principales:**
    - **A* (A-Star):** Busca el menor coste posible entre origen y destino usando una función que combina la distancia actual y la estimada a la meta.
        - _Desventaja:_ Requiere gran almacenamiento de nodos.
    - **Escalada (Hill Climbing):** Búsqueda local que avanza hacia el mejor vecino (máxima pendiente) sin recordar el pasado.
        - _Problemas:_ Puede atascarse en máximos locales, mesetas o crestas.
    - **Recocido Simulado (Simulated Annealing):** Proceso estocástico inspirado en la termodinámica. Usa una "temperatura" que desciende lentamente para permitir movimientos no óptimos al inicio y evitar quedarse en óptimos locales.
#### C. Búsqueda con Adversario

Se aplica en problemas donde hay más de un agente (juegos) y un oponente modifica el estado del sistema.
- **Enfoque:** Se busca llevar el problema a la mejor situación propia, asumiendo que el adversario llevará el problema a la peor situación para nosotros.
- **Algoritmo Minimax:** Minimiza la pérdida máxima esperada. Es recursivo y asume información completa.
- **Poda Alfa-Beta:** Técnica para optimizar Minimax reduciendo el número de nodos evaluados.
    - Se deja de analizar una rama si se encuentra que $\alpha \ge \beta$ (donde $\alpha$ es el valor asegurado por el jugador MAX y $\beta$ el valor asegurado por el jugador MIN).

### 4. Ejemplos Prácticos Mencionado

- **8-Puzzle:** Una matriz de 3x3 con 8 elementos que deben ordenarse moviendo el espacio vacío.
- **Juegos:** Ajedrez (con adversario) y Puzzle (sin adversario)30.

### 5. Medidas de Complejidad en Grafos

Para medir la complejidad en el espacio de estados:

- $b$: Factor de ramificación (número de sucesores).
- $d$: Profundidad de la solución más superficial.
- $m$: Profundidad máxima del árbol.


## A* 
https://www.datacamp.com/es/tutorial/a-star-algorithm

El algoritmo A* combina los mejores aspectos de otros dos algoritmos:

1. [Algoritmo de Dijkstra](https://www.datacamp.com/es/tutorial/dijkstra-algorithm-in-python): Este algoritmo encuentra el camino más corto a todos los nodos desde un único nodo origen.
2. Búsqueda codiciosa del mejor primero: Este algoritmo explora el nodo que parece estar más cerca del objetivo, basándose en una función heurística.

Imagina que intentas encontrar en un mapa la ruta más corta entre dos ciudades. Mientras que el algoritmo de Dijkstra exploraría en todas direcciones y la Búsqueda Mejor Primero podría dirigirse directamente hacia el destino (omitiendo potencialmente atajos), A* hace algo más inteligente. Considera ambas cosas:

- La distancia ya recorrida desde el inicio
- Una estimación inteligente de la distancia restante hasta la meta

Esta combinación ayuda a A* a tomar decisiones informadas sobre qué camino explorar a continuación, haciéndolo a la vez eficiente y preciso.


## ¿Qué es un algoritmo de escalada de colinas en IA?
https://www.datacamp.com/tutorial/hill-climbing-algorithm-for-ai-in-python
Subir cuestas es una forma sencilla en que las computadoras resuelven problemas encontrando la mejor solución posible, como un excursionista que intenta alcanzar la cima de una montaña. En inteligencia artificial (IA), a menudo necesitamos encontrar la mejor solución entre muchas opciones posibles. Esto se llama optimización.

Imagina intentar encontrar el punto más alto mientras juegas a "calor y frío". En este juego, solo puedes comprobar si te estás calentando (mejor) o enfriando (peor) a medida que te mueves. Subir cuestas funciona de la misma manera: busca soluciones cercanas y se dirige hacia las mejores.

Así es como funciona en sencillos pasos:

1. Comience con cualquier solución posible
2. Mira las soluciones cercanas
3. Si una solución cercana es mejor, muévete hacia ella
4. Continúe repitiendo los pasos 2 y 3 hasta que no se puedan encontrar mejores soluciones.

Por ejemplo, si estás intentando enseñar a un robot a caminar, Hill Climbing podría:

- Comience con movimientos aleatorios de las piernas.
- Pruebe movimientos ligeramente diferentes
- Conserva los que ayudan al robot a caminar mejor.
- Repita hasta encontrar el mejor patrón de caminata.

Si bien subir pendientes no siempre es el método más avanzado en IA, es un componente importante que nos ayuda a comprender cómo las computadoras pueden resolver problemas por sí solas, de manera similar al [algoritmo minimax](https://www.datacamp.com/tutorial/minimax-algorithm-for-ai-in-python) .

https://medium.com/estudio-de-datos/algoritmo-de-recocido-simulado-o-simulated-annealing-234f567677d9

## Algoritmo de recocido simulado o Simulated Annealing (SA)

Este algoritmo se compone de 4 pasos:

1. Comenzamos en un punto aleatorio x.
2. Escogemos un punto nuevo xⱼ dentro de una vecindad N(x).
3. Decidimos si nos movemos al nuevo punto xⱼ. Esta decisión se hará en base a la función de probabilidad P(x,xⱼ,T) que explicaremos a continuación.
4. Disminuimos T.

Como hemos mencionado antes la función de probabilidad P(x,xⱼ,T) sera la que nos ayude a decidir si nos movemos al nuevo punto, esta función se ve de esta forma: